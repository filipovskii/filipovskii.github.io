<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Boris</title>
    <atom:link href="http://filipovskii.github.com/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <link>http://filipovskii.github.com</link>
    <description>tech blog by russian guy</description>
    <pubDate>Sun, 25  Aug 2013 04:00:00 +0400</pubDate>
    <generator>Wintersmith - https://github.com/jnordberg/wintersmith</generator>
    <language>en</language>
    <item>
      <title>Storing data, the easy way</title>
      <link>http://filipovskii.github.com/articles/data-easy-way/</link>
      <pubDate>Sun, 25  Aug 2013 04:00:00 +0400</pubDate>
      <guid isPermaLink="true">http://filipovskii.github.com/articles/data-easy-way/</guid>
      <author></author>
      <description>&lt;p&gt;Choosing appropriate data storage is one of the first and most important
decisions you have to face once you&amp;#39;ve started implementing an application
(at least in web or mobile world). There are lots of possibilities out
there, SQL and NoSQL, documents and objects and graphs and tables and
whatnot. But I want to talk about those cases, when a fully-featured
database for storing your data may be either not enough or too much.
&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;To be clear, by database I mean &lt;a href=&quot;http://en.wikipedia.org/wiki/Database&quot;&gt;DBMS&lt;/a&gt; or database management
system, and by data storage I mean any organized representation of your
data.&lt;/p&gt;
&lt;h2&gt;RAM&lt;/h2&gt;
&lt;p&gt;That&amp;#39;s pretty obvious. You need to store non-critical data and have fast
access to it &amp;mdash; use RAM. Classical use cases include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Mock storage for unit tests&lt;/p&gt;
&lt;p&gt;Instead of running your tests using real database, sometimes it&amp;#39;s
easier to mock storage using some build-in collections like lists,
dictionaries (aka maps) etc.&lt;/p&gt;
&lt;p&gt;It forces you to write database-agnostic code, isolate storage
interaction and concentrate on application logic. Which is a good
thing, obviously.&lt;/p&gt;
&lt;p&gt;Here is an example of a simple mock in javascript:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; users = {}; &lt;span class=&quot;comment&quot;&gt;// fill this with mock data&lt;/span&gt;

    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getUserById&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(id)&lt;/span&gt; {&lt;/span&gt;
      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; users[id];
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Cache&lt;/p&gt;
&lt;p&gt;Instead of reading often used data from disk all the time, cache it in
memory! It is fast and nothing inevitable can happen once your app
unexpectedly shut down.&lt;/p&gt;
&lt;p&gt;I use it a lot. In the most recent project, I&amp;#39;ve been working on, all
the vital data gets loaded into cache in RAM on application start up
and is updated in cache first, before any changes get stored to disk.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pre-aggregation&lt;/p&gt;
&lt;p&gt;Suppose you need to track page views on popular site&amp;hellip; all of
them. That&amp;#39;s a lot of data. Writing each page view to disk real-time
will certainly lead to performance issues.&lt;/p&gt;
&lt;p&gt;It is possible to improve performance by storing data in RAM first,
and flushing it to disk every now and then. To optimize even more in
case you need to track just certain parameters (e.g. User-Agent),
pre-aggregate data based on those and then flush it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Chrome    300 visits
Firefox   220 visits&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is a chance of losing data, while it is not on the disk. That&amp;#39;s
a price you have to pay for performance. Think about how much data you
can afford to loose and tweak &lt;em&gt;period in which flushing occurs&lt;/em&gt;
accordingly.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://heymoose.com/&quot;&gt;Heymoose&lt;/a&gt;, advertising platform I was working on,
uses this tactics to store ad shows and clicks.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course there are more possible use cases. The general idea is: “If
you want to keep things simple and you&amp;#39;re not afraid to loose data up
to some point, RAM is a great easy-to-use storage available out of (your
favourite language) box.”&lt;/p&gt;
&lt;h2&gt;Files&lt;/h2&gt;
&lt;p&gt;This is &lt;em&gt;the most underestimated storage&lt;/em&gt; in web development of all time.
I think it all began with &lt;a href=&quot;http://en.wikipedia.org/wiki/LAMP_(software_bundle)&quot;&gt;LAMP&lt;/a&gt;. &lt;em&gt;MySQL&lt;/em&gt; became a minimum
requirement for building a website, thus the simplest, fastest and
sometimes even more reliable storage forgotten&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Plain-text files&lt;/em&gt; can be used for lots of stuff, although there are
certain use cases, when they are simply the best fit for the job:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Log-like data&lt;/p&gt;
&lt;p&gt;Access logs, error logs, debug logs &amp;mdash; this is a huge amount of
important data. Applications do not tend to use &lt;em&gt;DBMS&lt;/em&gt; for this. It&amp;#39;s
simpler and faster to write to files.  And, most importantly, it
&lt;em&gt;reduces the number of levels of complexity&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In the past I was working on &lt;a href=&quot;http://en.wikipedia.org/wiki/Financial_Information_eXchange&quot;&gt;FIX&lt;/a&gt; traffic analyser tool. The
low level part of this project was written in C and was responsible
for capturing and writing FIX messages into rotated log. High level
part was providing a fancy web interface for searching and analyzing
those messages.&lt;/p&gt;
&lt;p&gt;Amount of data was huge, DBMS would require lots of resources to
handle it. With files (in conjunction with with pre-aggregation) it
became possible.&lt;/p&gt;
&lt;p&gt;Indexing and searching through this data was implemented with
&lt;a href=&quot;http://www.elasticsearch.org/&quot;&gt;ElasticSearch&lt;/a&gt;. It all worked like a charm!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Replacement for a database with a simple structure&lt;/p&gt;
&lt;p&gt;For prototypes, tests or even working apps, it is possible to use
files to store your data like you would use a database:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;db
├── painters
│   ├── k.malevich@square.io.json
│   ├── r.falk@msk.ru.json
│   └── v.kandinsky@circles.ru.json
└── paintings
    ├── black-square.json
    ├── moscow-I.json
    └── portrait-of-a-tatar-journalist-midhat-refatov.json&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Working with files in high-level languages is fun and easy. Considering
&lt;a href=&quot;http://en.wikipedia.org/wiki/Page_cache&quot;&gt;caching&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Epoll&quot;&gt;epoll&lt;/a&gt; and other cool options, it can also
be very efficient and convenient.&lt;/p&gt;
&lt;h2&gt;To summarize&lt;/h2&gt;
&lt;p&gt;Storing your data is not only about MySQL, PostgreSQL, MongoDB etc. Very
often compound solutions may lead to cleaner code, higher performance and
flexibility. And sometimes you don&amp;#39;t even need fully-featured DBMS at all.&lt;/p&gt;
&lt;p&gt;Use programs that do one thing and do it well. Use programs to work
together.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Rethinking DRY and KISS</title>
      <link>http://filipovskii.github.com/articles/code-quality-metrics/</link>
      <pubDate>Sun, 21 Jul 2013 04:00:00 +0400</pubDate>
      <guid isPermaLink="true">http://filipovskii.github.com/articles/code-quality-metrics/</guid>
      <author></author>
      <description>&lt;p&gt;Every programmer instantly measures quality of code, whether it is his
(her/their?) own masterpiece, or some crap written by some other guy. And
there are lots of metrics defined by smart people out there, that help you
in this
(&lt;a href=&quot;http://en.wikipedia.org/wiki/Cohesion_%28computer_science%29&quot;&gt;cohesion&lt;/a&gt;,
&lt;a href=&quot;http://en.wikipedia.org/wiki/Code_coverage&quot;&gt;code coverage&lt;/a&gt;,
&lt;a href=&quot;http://www.osnews.com/story/19266/WTFs_m&quot;&gt;WTFs/minute&lt;/a&gt;). Well, I‘m no
exception, and just recently I’ve started to think about what am I paying
attention to in the first place.  &lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Turned out, there are just two things, that bother me most of the time:
&lt;strong&gt;complexity&lt;/strong&gt; and &lt;strong&gt;duplication&lt;/strong&gt;. This is all I need to tell whether code
I‘m looking at is worth something.. And that’s what &lt;strong&gt;DRY&lt;/strong&gt; (don&amp;#39;t repeat
yourself) and &lt;strong&gt;KISS&lt;/strong&gt; (keep it super simple) are about.&lt;/p&gt;
&lt;h2&gt;Complexity&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Writing software is hard!&lt;/em&gt; You have to joggle all this abstract concepts,
think about what library to use and how efficient your code is and so on.
Years spent doing this made me come to a simple conclusion:&lt;/p&gt;
&lt;p&gt;I am not that smart.&lt;/p&gt;
&lt;p&gt;There are people that can handle it much better than me. They can keep in
mind &lt;em&gt;stack traces 200 calls long&lt;/em&gt;, name you all &lt;em&gt;70 functions&lt;/em&gt; of a module
in alphabetical order and tell what is that &lt;em&gt;100 lines of code block&lt;/em&gt; doing
just by looking at it for 5 secs.&lt;/p&gt;
&lt;p&gt;I can&amp;#39;t. These things matter to me:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Actual size of code&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Number of levels of abstraction&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Number of condition operators&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Presence of naming conventions&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Number of third party libraries used&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A lot more..&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Looking at code I ask myself:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Is the purpose of this function/method/class obvious and &lt;em&gt;unambiguous&lt;/em&gt;?&lt;/p&gt;
&lt;p&gt;Or should I change its name, signature, remove it, break into several
smaller peaces, or merge into greater meaningful peace.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Is this level of abstraction necessary? &lt;em&gt;Does it remove any duplication?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Introducing unnecessary abstractions is, sadly, one of the most favourite
activities of contemporary programmer. Too many abstractions make code
harder to understand, debug and …yeah… change. So &lt;a href=&quot;http://pyvideo.org/video/880/stop-writing-classes&quot;&gt;use functions
instead of classes&lt;/a&gt;,
lightweight frameworks instead of huge &lt;code&gt;MV(\w*)C&lt;/code&gt; beasts, and no ORMs,
&lt;em&gt;please&lt;/em&gt;!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Is it absolutely inevitably to use inheritance? In most cases it adds
incredible amount of complexity.&lt;/p&gt;
&lt;p&gt;Should I use composition? Oh look, they even got
&lt;a href=&quot;http://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;wikipedia&lt;/a&gt;
article for this..&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Do I &lt;em&gt;need&lt;/em&gt; this third party library here?&lt;/p&gt;
&lt;p&gt;First answer should be &lt;em&gt;NO&lt;/em&gt;, cause everyone working with this code will
also need to understand how this library works and foreign code may
introduce subtle bugs and/or performance issues.&lt;/p&gt;
&lt;p&gt;Won&amp;#39;t it be easier to write something using just standard libs first?&lt;/p&gt;
&lt;p&gt;If I‘m absolutely sure, I will look through its source and check if it’s
still actively supported by community before adding this library to the
project.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/presentations/Simple-Made-Easy&quot;&gt;“Simple made easy” by Rich
Hickey&lt;/a&gt; is a great
source of inspiration for me when it comes to complexity in software. I
strongly recommend watching it, regardless of your opinion about &lt;em&gt;Closure&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Duplication&lt;/h2&gt;
&lt;p&gt;Although it seems superficial, &lt;em&gt;code duplication&lt;/em&gt;, in my opinion, is a
fundamental problem in software engineering. All this complex concepts, such
as design patterns and programming paradigms serve just one purpose - remove
duplication from code. That&amp;#39;s it. &lt;em&gt;It is that simple!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Same or &lt;em&gt;roughly similar&lt;/em&gt; code in several different places is bad. You have
to keep in mind all these peaces and change them simultaneously. Well…
you know.&lt;/p&gt;
&lt;p&gt;I began to realize this mostly after reading some of the books on TDD by
&lt;a href=&quot;http://en.wikipedia.org/wiki/Kent_Beck&quot;&gt;Kent Beck&lt;/a&gt;, which I again strongly
recommend.&lt;/p&gt;
&lt;p&gt;Interesting thing is that there is &lt;em&gt;only one way&lt;/em&gt; to solve this problem of
similar code. And that is complicating things. &lt;em&gt;What an irony!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Think about it.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Once I see a duplication (aka &lt;em&gt;reusable behavior&lt;/em&gt;), I abstract it in a
class or function or module or even whole abstraction layer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Instead of writing my own implementation of http-protocol (&lt;em&gt;duplicating
something somebody else wrote&lt;/em&gt;) every time I develop a webapp, I simply
use a third-party library.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Tradeoff&lt;/h2&gt;
&lt;p&gt;All I am saying is that without oversimplifying things, &lt;strong&gt;complexity&lt;/strong&gt;
and &lt;strong&gt;duplication&lt;/strong&gt; are all I really care about in programming.&lt;/p&gt;
&lt;p&gt;Like most things in the industry, you need to find a tradeoff between
those two. Removing duplication leads to increasing complexity and
sometimes vice versa.  Depending on situation, project,
time-performance-[other] constrains I prefer one over another. Sometimes I
make a decision, that implies some duplication, and only if it keeps
bothering me, I refactor it later. It&amp;#39;s important that &lt;strong&gt;common sense
plays the main role in it!&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;“All theory is gray, my friend. But forever green is the tree of life.”&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That‘s why I’m going to write about some cases, where I apply this two
criterions, in future posts.&lt;/p&gt;
&lt;p&gt;Till then!&lt;/p&gt;
</description>
    </item>
  </channel>
</rss>